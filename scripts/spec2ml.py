#!/usr/bin/env python3
from pathlib import Path
from argparse import ArgumentParser


def read_spec(spec_p: Path):
    opcodes = {}
    specs = spec_p.read_text().split("\n")
    for op_spec in specs:
        splitted = op_spec.strip().split(",")
        opcode, operands = splitted[0], splitted[1:]
        kind = "".join(operands)

        if kind == "":
            kind = "unimpl"

        if kind not in opcodes:
            opcodes[kind] = [opcode]
        else:
            opcodes[kind].append(opcode)

    return opcodes


def gen_opcode(opcodes):
    '''Generate the `src/opcode.ml` from `spec/opcodes.spec`'''
    opcode_gen = "(* Generated by scripts/spec2ml.py *)\n"
    opcode_gen += "exception Invalid_opcode\n"

    kind_t = f"type kind = \n"

    for kind, opcode_group in opcodes.items():
        kind_t += f"  | {kind.upper()}\n"
    kind_t += "  | Empty\n\n"

    t = "type t = \n"
    of_str = ("let of_str str = \n"
              "  match str with\n")
    to_str = ("let to_str opcode = \n"
              "  match opcode with\n")
    get_kind = ("let get_kind opcode = \n"
                "  match opcode with\n")

    for kind, opcode_group in opcodes.items():
        t += f"  (* {kind} *)\n"

        for opcode in opcode_group:
            t += f"  | {opcode}"
            of_str += f"  | \"{opcode}\" ->  {opcode}\n"
            to_str += f"  |  {opcode} -> \"{opcode}\"\n"
            get_kind += f"  | {opcode}"
        get_kind += f" -> {kind.upper()}\n"
        t += "\n"
    t += "  | Empty\n\n"
    get_kind += "  | Empty -> Empty \n\n"
    of_str += "  | _ -> raise Invalid_opcode\n\n"
    to_str += "  | Empty -> failwith \"Unreachable\"\n\n"

    opcode_gen += kind_t
    opcode_gen += t
    opcode_gen += get_kind
    opcode_gen += "let empty = Empty\n\n"
    opcode_gen += of_str
    opcode_gen += to_str

    with open("src/opcode.ml", "w") as opcode_out:
        opcode_out.write(opcode_gen)


def gen_instr(opcodes):
    '''Generate the part of `src/instr.ml` from `specs/opcodes.spec`'''
    instr_gen = "\n(* Generated by scripts/spec2ml.py *)\n"
    match = "match opcode |> Opcode.get_kind with\n"

    operand_re = "([^,]*)"
    skip_re = "[^,]*, "

    for kind, _ in opcodes.items():
        if kind == "unimpl":
            continue

        match += f"| {kind.upper()} -> \n"
        p_idx = kind.find("p")
        brac_operands = []
        brac_re = "(?:\\\\["
        paren_operands = []
        paren_re = "\\\\("

        if p_idx != -1:
            brac_operands = kind[:p_idx].split("b")[1:]
            paren_operands = kind[p_idx:].split("p")[1:]
        else:
            brac_operands = kind.split("b")[1:]

        brac_operands = [0]+[int(_) for _ in brac_operands]

        for idx in range(1, len(brac_operands)):
            if idx != 1:
                brac_re += ", "
            bpos = brac_operands[idx]
            bpos_bef = brac_operands[idx-1]
            for _ in range(bpos-bpos_bef-1):
                brac_re += skip_re
            brac_re += operand_re
        brac_re += "[^\\\\]]*\\\\])"

        if len(paren_operands) > 0:
            brac_re += "{0,1}"

        paren_operands = [0]+[int(_) for _ in paren_operands]
        for idx in range(1, len(paren_operands)):
            if idx != 1:
                paren_re += ", "
            ppos = paren_operands[idx]
            ppos_bef = paren_operands[idx-1]
            for _ in range(ppos-ppos_bef-1):
                paren_re += skip_re
            paren_re += operand_re
        paren_re += "[^\\\\)]*\\\\)"
        operands_re = brac_re + paren_re

        match += (
            f"  let operands = instr |> parse_operands \"{operands_re}\" \n"
            f"  |> Array.to_list |> List.tl in\n"
            f"  create opcode operands\n")
    match += ("| UNIMPL -> create opcode []\n"
              "| _ -> failwith \"Unreachable\"")

    instr_gen += match
    instr_gen = ["  " + l for l in instr_gen.split("\n")]
    write_pos = -1
    instr_orig = []

    with open("src/instr.ml", "r") as instr_in:
        instr_orig = instr_in.readlines()
        write_pos = [l.strip() for l in instr_orig].index(
            "let opcode = parse_opcode instr in")

    with open("src/instr.ml", "w") as instr_out:
        instr_out.writelines(instr_orig[:write_pos+1])
        instr_out.write("\n".join(instr_gen))


if __name__ == "__main__":
    parser = ArgumentParser()
    parser.add_argument("--opcode", action="store_true",
                        help="Generate opcode.ml")
    parser.add_argument("--instr", action="store_true",
                        help="Generate instr.ml")

    args = parser.parse_args()

    spec_p = (Path(__file__).parent.parent /
              "specs" / "opcodes.spec").resolve()
    spec = read_spec(spec_p)

    if args.opcode:
        gen_opcode(spec)
    elif args.instr:
        gen_instr(spec)
    else:
        parser.print_help()
