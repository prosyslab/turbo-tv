exception Invalid_instruction of string * string

type t = Opcode.t * string list

let create opcode operands : t = (opcode, operands)
let empty : t = (Opcode.empty, [])

(* getter *)
let opcode (opcode, _) : Opcode.t = opcode
let operands (_, operands) : string list = operands

let err instr reason =
  Printf.fprintf stderr "Invalid Instruction: %s\n%s\n\n" instr reason;
  raise (Invalid_instruction (instr, reason))

let create_from instr =
  let parse_opcode instr =
    let opcode_reg = Re.Pcre.regexp "#[a-zA-Z0-9]+:([a-zA-Z0-9]+)" in
    try Re.Group.get (Re.exec opcode_reg instr) 1 |> Opcode.of_str with
    | Not_found ->
        let reason = "Cannot match 'opcode' from the instruction." in
        err instr reason
    | Opcode.Invalid_opcode ->
        let reason =
          "Unknown opcode: " ^ Re.Group.get (Re.exec opcode_reg instr) 1
        in
        err instr reason
  in

  let parse_operands regstr instr =
    let re = Re.Pcre.regexp regstr in
    try Re.exec re instr |> Re.Group.all
    with Not_found ->
      let reason = "Cannot parse operands with " ^ regstr in
      err instr reason
  in

  let opcode = parse_opcode instr in

  (* Generated by scripts/spec2ml.py *)
  match opcode |> Opcode.get_kind with
  | P1 ->
      let operands =
        instr
        |> parse_operands "(?:\\[[^\\]]*\\]){0,1}\\(([^,]*)[^\\)]*\\)"
        |> Array.to_list |> List.tl
      in
      create opcode operands
  | B1 ->
      let operands =
        instr
        |> parse_operands "(?:\\[([^,]*)[^\\]]*\\])\\([^\\)]*\\)"
        |> Array.to_list |> List.tl
      in
      create opcode operands
  | P1P2 ->
      let operands =
        instr
        |> parse_operands "(?:\\[[^\\]]*\\]){0,1}\\(([^,]*), ([^,]*)[^\\)]*\\)"
        |> Array.to_list |> List.tl
      in
      create opcode operands
  | UNIMPL -> create opcode []
  | _ -> failwith "Unreachable"
